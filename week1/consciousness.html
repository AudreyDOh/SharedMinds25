<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Through Curtains - Consciousness Experience</title>
  <style>
    body {
      background: black;
      margin: 0;
      overflow: hidden;
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    canvas {
      display: block;
    }
    #controls {
      background: #111;
      width: 100%;
      padding: 10px;
      text-align: center;
    }
    input {
      font-size: 18px;
      padding: 8px;
      width: 60%;
      border: none;
      border-radius: 5px;
    }
  </style>
</head>
<body>
<canvas id="canvas"></canvas>
<div id="controls">
  <input id="wordInput" placeholder="Type a word and press Enter" />
</div>
<script>
const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");

function resize() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight - document.getElementById("controls").offsetHeight;
}
resize();
window.addEventListener("resize", resize);

let sourceX = canvas.width / 2;
let sourceY = canvas.height + 100; // below canvas
let direction = 1; // 1 = right, -1 = left
let speed = 2; // default
let isMoving = false; // NEW: track if source should be moving

// Array to store text positions
let textElements = [];

document.getElementById("wordInput").addEventListener("input", e => {
  const currentText = e.target.value;
  if (currentText.length > 0) {
    const lastChar = currentText[currentText.length - 1];
    // Add new character at random position
    textElements.push({
      char: lastChar,
      x: Math.random() * (canvas.width - 20) + 10,
      y: Math.random() * (canvas.height - 20) + 10,
      opacity: 1,
      age: 0
    });
  }
});

document.getElementById("wordInput").addEventListener("keydown", e => {
  if (e.key === "Enter") {
    // Start movement only when user presses Enter
    if (!isMoving) {
      isMoving = true;
    }
    const word = e.target.value.trim().toLowerCase();
    if (word.length > 0) {
      // map letters to speeds (1–10)
      const letterSpeeds = [...word].map(ch => {
        let code = ch.charCodeAt(0);
        return 1 + ((code - 97) % 26) / 25 * 9;
      });
      // average speed for the word
      speed = (letterSpeeds.reduce((a, b) => a + b, 0) / letterSpeeds.length) / 3;

      // direction rule: even-length → right, odd-length → left
      direction = (word.length % 2 === 0) ? 1 : -1;

      // reset position to bottom center each time
      sourceX = canvas.width / 2;

      e.target.value = "";
      // Clear existing text when enter is pressed
      textElements = [];
    }
  }
});

// --- Create 5 "almost random" slits at the bottom ---
const slitCount = 5;
const slits = [];
for (let i = 0; i < slitCount; i++) {
  slits.push({
    x: (canvas.width / (slitCount + 1)) * (i + 1) + (Math.random() * 40 - 20), // spaced, but jittered
    y: canvas.height + 8,
    r: 3 + Math.random() * 5 // radius between 3 and 8
  });
}

function drawBeam(sourceX, sourceY, slit) {
  const dx = slit.x - sourceX;
  const dy = slit.y - sourceY;
  const dist = Math.sqrt(dx*dx + dy*dy);

  const nx = dx / dist;
  const ny = dy / dist;

  const beamLength = canvas.height * 1.5;
  const endX = slit.x + nx * beamLength;
  const endY = slit.y + ny * beamLength;

  const gradient = ctx.createRadialGradient(
    slit.x, slit.y, 1,
    slit.x, slit.y, beamLength
  );
  gradient.addColorStop(0, "rgba(255,255,200,0.5)");
  gradient.addColorStop(0.2, "rgba(255,230,162,0.2)");
  gradient.addColorStop(1, "rgba(0,0,0,0)");

  ctx.fillStyle = gradient;

  ctx.beginPath();
  ctx.moveTo(sourceX, sourceY);
  ctx.lineTo(slit.x - slit.r, slit.y - slit.r);
  ctx.lineTo(endX, endY);
  ctx.lineTo(slit.x + slit.r, slit.y + slit.r);
  ctx.closePath();
  ctx.fill();
}

function updateSource() {
  // Only move if isMoving is true
  if (isMoving) {
    sourceX += direction * speed * 0.5;
  }
}

function drawText() {
  // Set text properties
  ctx.font = "14px Arial";
  ctx.textAlign = "center";
  
  // Update and draw each text element
  for (let i = textElements.length - 1; i >= 0; i--) {
    const textEl = textElements[i];
    
    // Age the text and fade it out
    textEl.age++;
    textEl.opacity = Math.max(0, 1 - (textEl.age / 300)); // Fade out over 300 frames
    
    // Draw the character
    ctx.fillStyle = `rgba(50, 50, 50, ${textEl.opacity})`; // Dark gray with opacity
    ctx.fillText(textEl.char, textEl.x, textEl.y);
    
    // Remove completely faded text
    if (textEl.opacity <= 0) {
      textElements.splice(i, 1);
    }
  }
}

function draw() {
  ctx.fillStyle = "rgba(0, 0, 0, 0.01)"; 
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  updateSource();

  // Only draw beams if moving (so no static light when page loads)
  if (isMoving) {
    for (let slit of slits) {
      drawBeam(sourceX, sourceY, slit);
    }
  }

  // Draw text elements
  drawText();

  ctx.fillStyle = "white";
  for (let slit of slits) {
    ctx.beginPath();
    ctx.arc(slit.x, slit.y, slit.r, 0, Math.PI*2);
    ctx.fill();
  }

  requestAnimationFrame(draw);
}
draw();
</script>
</body>
</html>